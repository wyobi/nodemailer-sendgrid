{"mappings":";;ACMA,kBAAyB,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,GAAG,IAAI,EAAE,IAAI,EAAE,CAAC,KAAK,IAAI,CAAC;ACHnE,QAAO,QAAQ,6BAA6B,CAAC,GAAG,GAAG,CAAE,YAAW,UAAU,CAAC,CAAC;IAC1E,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IACtB,QAAQ,CAAC,OAAO,EAAE,MAAM,CAAC;IAEzB,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC,EAAE,QAAQ,EAAE,aAAa,CAAC,CAAC,GAAG,IAAI;IAEpE,MAAM,CAAC,CAAC,QAAQ,EAAE,CAAC,GAAG,EAAE,KAAK,GAAG,IAAI,EAAE,OAAO,EAAE,IAAI,KAAK,IAAI,GAAG,IAAI;IACnE,MAAM,CAAC,IAAI,OAAO,CAAC,IAAI,CAAC;IAExB,KAAK,CAAC,IAAI,IAAI;CACf;ACID,gCAAgC;IAC9B,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB,CAAC;AAEF,+BAAwB,SAAQ,qBAAqB;IACnD,OAAO,EAAE,wBAAwB,CAAC;IAClC,IAAI,EAAE,MAAM,CAAC;IACb,OAAO,EAAE,MAAM,CAAC;gBAEJ,OAAO,EAAE,wBAAwB;IAUvC,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,aAAa,GAAG,CAAC;CA+I1D;AAED,OAAO,MAAM,uBAAuB,YAAa,wBAAwB,sBACzC,CAAC;AAEjC,eAAe,uBAAuB,CAAC","sources":["src/src/helpers.ts","src/src/types.ts","src/src/base.ts","src/src/index.ts","src/index.ts"],"sourcesContent":[null,null,null,null,"import { name, version } from \"../package.json\";\nimport { MailService } from \"@sendgrid/mail\";\n\nimport {\n  readableStreamToString,\n  isDefined,\n  mapStringOrAddress,\n} from \"./helpers\";\nimport type {\n  SendCallback,\n  Mail,\n  AttachmentData,\n  MailDataRequired,\n  MailMessage,\n} from \"./types\";\nimport { SendGridTransportBase } from \"./base\";\n\ntype SendGridTransportOptions = {\n  apiKey?: string;\n};\n\nclass SendGridTransport extends SendGridTransportBase {\n  options: SendGridTransportOptions;\n  name: string;\n  version: string;\n  private sgMail = new MailService();\n  constructor(options: SendGridTransportOptions) {\n    super();\n    this.options = options ?? {};\n    this.name = name;\n    this.version = version;\n    if (options.apiKey) {\n      this.sgMail.setApiKey(options.apiKey);\n    }\n  }\n\n  async send(mail: MailMessage, callback: SendCallback<any>) {\n    try {\n      const msg = await new Promise((resolve, reject) => {\n        mail.normalize((err, _source) => {\n          if (err) {\n            return reject(err);\n          }\n          \n          const msg: Partial<MailDataRequired> = {};\n          const source = _source ?? {};\n          Object.keys(source ?? {}).forEach((key) => {\n            switch (key) {\n              case \"subject\":\n              case \"text\":\n              case \"html\":\n                msg[key] = source[key] as any;\n                break;\n              case \"from\":\n              case \"replyTo\":\n                msg[key] = [source[key] ?? []]\n                  .flat()\n                  .map(mapStringOrAddress)\n                  .shift();\n                break;\n              case \"to\":\n              case \"cc\":\n              case \"bcc\":\n                msg[key] = [source[key] ?? []].flat().map(mapStringOrAddress);\n                break;\n              case \"attachments\":\n                this.handleAttachments(source, msg);\n                break;\n              case \"alternatives\":\n                this.handleAlternatives(source, msg);\n                break;\n              case \"icalEvent\":\n                {\n                  let attachment: AttachmentData = {\n                    content: readableStreamToString(\n                      (source.icalEvent as Mail.IcalAttachment).content ?? \"\"\n                    ),\n                    filename:\n                      (source.icalEvent as Mail.IcalAttachment).filename ||\n                      \"invite.ics\",\n                    type: \"application/ics\",\n                    disposition: \"attachment\",\n                  };\n                  msg.attachments = (msg.attachments ?? []).concat(attachment);\n                }\n                break;\n              case \"watchHtml\":\n                {\n                  let alternative = {\n                    content: source.watchHtml,\n                    type: \"text/watch-html\",\n                  };\n                  msg.content = (msg.content ?? []).concat(alternative as any);\n                }\n                break;\n              case \"normalizedHeaders\":\n                /*\n                            const headers = msg.headers || {};\n                            Object.keys(source.normalizedHeaders || {}).forEach(header => {\n                                headers[header] = source.normalizedHeaders[header];\n                            });\n    \n                            msg.headers = headers*/\n                break;\n              case \"messageId\":\n                msg.headers = msg.headers ?? {};\n                msg.headers[\"message-id\"] = source.messageId!;\n                break;\n              default:\n                (msg as any)[key] = (source as any)[key];\n            }\n          });\n    \n          if (msg?.content?.length) {\n            if (msg.text) {\n              msg.content.unshift({ type: \"text/plain\", value: msg.text });\n              delete msg.text;\n            }\n            if (msg.html) {\n              msg.content.unshift({ type: \"text/html\", value: msg.html });\n              delete msg.html;\n            }\n          }\n\n          resolve(msg);\n        });\n      })\n\n      return await this.sgMail.send(msg as MailDataRequired, callback as any);\n    }\n    catch(err) {\n      if(callback) {\n        callback(err as Error | null, null);\n      }\n      else {\n        throw err;\n      }\n    }\n  }\n  \n  private handleAlternatives(\n    source: Mail.Options,\n    msg: Partial<MailDataRequired>\n  ) {\n    if (!source.alternatives) return;\n    const alternatives = source.alternatives.map((entry) => {\n      const alternative = {\n        value: readableStreamToString(entry.content ?? \"\"),\n        type: entry.contentType!,\n      };\n      return alternative;\n    });\n\n    msg.content = (msg.content ?? []).concat(alternatives);\n  }\n\n  private handleAttachments(\n    source: Mail.Options,\n    msg: Partial<MailDataRequired>\n  ) {\n    const attachments = (source.attachments ?? [])\n      .map((entry) => {\n        if (!entry.content || !entry.filename) return;\n        const attachment: AttachmentData = {\n          content: readableStreamToString(entry.content),\n          filename: entry.filename,\n          type: entry.contentType,\n          disposition: \"attachment\",\n        };\n        if (entry.cid) {\n          attachment.contentId = entry.cid;\n          attachment.disposition = \"inline\";\n        }\n        return attachment;\n      })\n      .filter(isDefined);\n\n    msg.attachments = (msg.attachments ?? []).concat(attachments);\n  }\n}\n\nexport const createSendGridTransport = (options: SendGridTransportOptions) =>\n  new SendGridTransport(options);\n\nexport default createSendGridTransport;\n"],"names":[],"version":3,"file":"main.d.ts.map","sourceRoot":"../"}